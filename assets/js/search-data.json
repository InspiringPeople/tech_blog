{
  
    
        "post0": {
            "title": "Bert",
            "content": "BERT . By Google (2018.10 논문이 공개, 11월에 오픈 소스로 공개 됨) . | BERT는 Bidirectional Encoder Representations from Transformers . | “Attention is all you need” (2017년 논문)에서 소개한 Transformer의 Encoder 부분 사용 . | Github : https://github.com/google-research/bert . | Paper : https://arxiv.org/abs/1810.04805 . | . . [Transformer Architecture] . 1) Transformer Encoder . 2) Transformer Decoder . Bert에서는 Transformer의 Encoder Block만을 사용 . Bert base 모델은 Encoder Block을 12개, Bert large 모델은 24개 쌓아서 만듬. . (Transformer의 Decoder Block을 쓰는 모델은 GPT 계열 모델, Encoder / Decoder Block을 모두 쓰는 모델은 T5 등이 있다) . 주요 개념 . Bert의 자세한 내용을 살펴보기 전에, Bert를 이해하기 위한 주요 개념들에 대해 소개한다. . Transfer Learning . . 패러다임의 전환! . BERT는 기본적으로, wiki나 book data와 같은 대용량 unlabeled data로 모델을 미리 학습 시킨 후, 특정 task를 가지고 있는 labeled data로 transfer learning을 하는 모델이다. 이때 unlabeled data로 학습하는 과정을 pre-training (upstream task), labeled data로 학습하는 과정을 fine-tuning (downstream task)라고 지칭한다. | . . Bert의 Pre-training / Fine-tuning . Bert는 wiki, book corpus 데이터로 pre-training을 수행하여 General purpose의 언어모델 (Language Model)을 학습하고, 다양한 task에 따라 (Glue, Super Glue 등) fine-tuning 모델을 생성하는 방식이다. 이로써 적은 labeling data로도 SOTA 모델을 만들 수 있다. . Language Model은 어떤 방식으로 문맥을 학습할까? (Transformer 계열 모델) . Attention . Attention이란? . 인간은 정보처리를 할 때 모든 sequence를 고려하지 않음. 찾아야 하는 주요 정보가 무엇인지 알 수 있다면 이에 가중치를 주어, 주요 정보를 중심으로 맥락을 파악할 수 있음. Attention의 모티브는 자신에게 의미 있는 feature만 골라내서 중요하게 판단하겠다는 것임. . 논문 : Neural Machine Translation by Jointly Learning to Align and Translate (https://arxiv.org/abs/1409.0473), 조경현 교수님 . | 어텐션 매커니즘은 기계번역(machine translation)을 위한 sequence-to-sequence 모델(S2S)에 처음 도입 . | 번역 시 소스랭귀지와 타겟랭귀지의 길이가 길어질 수록 모델의 성능이 나빠짐, 이를 방지하기 위해 모델로 하여금 ‘중요한 부분만 집중(attention)하게 만들자’는 것이 어텐션 매커니즘의 핵심 아이디어 . | 어텐션은 weights의 중요도 벡터, 이미지의 픽셀값이나 문장에서 단어 등 어떤 요소를 예측하거나 추정하기 위해, 다른 요소들과 얼마나 강하게 연관되어 있는지 확인하고 어텐션 백터로 가중 합산된 값의 합계를 타겟값으로 추정 . | . Input 중에서 무엇이 중요한지는 attention weight로 학습이 가능하며, input과 output이 어떻게 연결되어 있는지 시각화가 가능함. (어떤 feature들이 연결되어 있는지 알 수 있음) . . 기존 Attention 방식의 단점 . 번역모델(Seq2Seq) Attention 메커니즘의 핵심은 decoder의 특정 time-step의 output이 encoder의 모든 time-step의 output 중 어떤 time-step과 가장 연관이 있는가임. 일반적인 Seq2Seq-Attention 모델에서의 번역 태스크의 문제는 원본 언어(Source Language), 번역된 언어(Target Language)간의 대응 여부는 Attention을 통해 찾을 수 있었음. (input 나는 소년이다 &lt;-&gt; output I am a boy 간에 ‘나’ 와 ‘I’, ‘소년’과 ‘boy’의 대응관계) . | 그러나 각 문장에서의 관계를 나타낼 수 없음. ‘I love tiger but it is scare’에서 ‘it’이 무엇을 나타내는지 와 같은 문제는 기존 Encoder-Decoder 기반의 Attention메커니즘에서는 찾을 수 없었음. . | Attention 모델은 Seq2seq의 성능을 높였으나, RNN이 순차로 이뤄져 연산이 느리다는 구조적인 문제점이 있음. 또한 병렬처리가 불가능함. 이런 단점을 해결하기 위해 RNN을 없애는 아이디어가 나오게 됨. . | . Self-attention . Self-attention이란? . 2017년 구글이 발표한 논문인 “Attention is all you need” (https://papers.nips.cc/paper/7181-attention-is-all-you-need.pdf)에서 제안된 transformer model에서 소개된 방법 . | 기존의 seq2seq의 구조인 인코더-디코더 따르면서도 순환신경만 기반으로 구성된 기존 모델과 다르게 단순히 어텐션 구조만으로 전체 모델을 만들어 어텐션 기법의 중요성을 강조 . | 문장 내에서 token들이 스스로를 잘 표현하는 context vector를 갖게 만듦. . | . . 밑줄 친 부분에 따라 it에 대한 가중치가 달라짐 . Bert has multi-head attention : Bert is multi-headed beast! . Bert base 모델의 경우 Layer 12, attention head 12개 architecture를 가지고 있다. . | 따라서 12*12 = 144, 144개의 distinct attention을 갖게 됨 . | . . L2, H0: Attention to next word . . L6, H11: Attention to previous word . . L2, H1: Attention to other words predictive of word . 기존의 word2vec 같은 경우 하나의 단어는 하나의 vector 값만을 표현하였지만, transformer 계열 모델의 경우 multi-headed attention을 이용함으로써 하나의 단어가 여러 개의 “representation 공간”을 가질 수 있게 됨. . 2. Pre-training . Bert의 pre-training 과정은 크게 Input Embedding, MLM, NSP 3가지 과정으로 나눠진다. . Pre-training data (BERT base) . BookCorpus (Zhu et al., 2015) (800M words) + English Wikipedia (2,500M words) . | Unsupervised Learning으로 진행됨 . | long contiguous sequence만을 학습시키기 위해 Wikipedia는 text passage만 추출하여 사용 . | . . BERT의 Pre-training과 Fine-tuning . BERT의 Pre-training은 tokenization을 수행하여 embedding 된 Sentence 2개를 Input Data로 사용한다. (Input Data 생성에 대해서는 후술) Input 값은 Transformer layer를 거치며 문장 내에서 단어(token)스스로를 가장 잘 표현하는 Self-attention된 token vector(Contextual representation of token), 그리고 후술할 NSP(Next Sentence Prediction)와 MLM(Masked Language Model)을 거치며 언어의 맥락 정보를 저장한 모델을 구축함. . 이 후 Fine-tuning 과정에서는 pre-training 된 모델을 로드하여, MNLI, NER, SQuAD와 같은 다양한 NLP Classification task를 수행하는 labeled train data를 학습시켜 분류를 하게 됨. . 2) Tokenization . Subword segmentation . 단어 분리(Subword segmenation) 작업은 하나의 단어는 (단어보다 작은 단위의) 의미있는 여러 내부 단어들(subwords)의 조합으로 구성된 경우가 많기 때문에, 하나의 단어를 여러 내부 단어로 분리해서 단어를 이해해보겠다는 의도를 가진 전처리 작업 . | 더 적은 vocab으로 더 많은 단어를 표현하고 out of vocabulary 방지 . | . Bert의 Tokenization은 Subword segmentation의 하나인 WPM(word piece model, by Google) 기반으로 tokenization 된다. . Bert Tokenizer 모음 . Tokenization 과정 . Space 단위로 token 분리 . | Pretrained 된 WPM tokenizer 기준으로 subwords segmentation . | 문장 시작에 [CLS], 문장 끝에 [SEP], max_seq_len에 따라 [PAD] special token 붙이기 . | . 3) Input Embedding . Tokenization된 문장은 Token Embeddings, Sentence Embeddings, Positional Embedings를 합쳐 모델에 입력할 수 있는 Input Embedding 값으로 변환된다. . . BERT는 Input data로 3 가지의 vector들이 합쳐서 만들어짐 . 1) Token Embeddings : Input에 들어갈 2개의 문장을 단어 token 단위로 자르고 token을 수학적으로 표현함. 이후 NSL와 MLM을 실시하기 위해, sentence 순서를 50% 확률로 변경하고, 15%의 token을 masking함. Masked token의 80%는 masked([MSK])되고, 10%는 그대로, 10%는 다른 token으로 치환하게 됨. special token으로는 문장 가장 앞([CLS])과 문장이 분리되는 부분([SEP])에 들어가게 됨. . 2) Segment Embeddings : 문장의 순서를 Embedding함. 그림 상에서 A, B로 표현됨. . 3) Position Embeddings : 단어의 순서를 Embedding함. (Transformer는 RNN이나 CNN처럼 data를 순차적으로 연산하지 않기 때문에 단어와 문장의 순서정보를 token에 별도로 넣어줘야 함) 또한 같은 단어라도 쓰인 위치에 따라 다른 임베딩 값을 가질 수 있음 . . 4 )MLM (Masked Language Model) . token embedding 과정에서 각 문장 token을 15% 확률로 masked 하게 되며, (문맥을 계산하여) masked token이 무엇인지를 예측하는 학습을 진행함. . . 입력 token의 15%를 선택하여 80% [MASK], 10% 랜덤토큰대체, 10% 유지 . . 5) NSP (Next Sentence Prediction) . NSP를 위해 corpus에서 실제 next sentence와 random sentence를 50% 확률로 가져오게 되며, 이를 가지고 IsNext인지 NotNext인지를 예측하는 학습을 진행. (Segment embedding으로 문장의 순서 정보를 보존) . sentence_a = “신용 대출을 신청 하고 싶어요” . sentence_b = “대출 관련 서류를 준비해 오셨어요?” . Label: IsNext . sentence_a = “신용 대출을 신청 하고 싶어요” . sentence_b = ”어떤 팀이 올해 프로야구 우승 했나요?” . Label: NotNext . | . MLM &amp; NSP 방식 . . 3. Fine-tuning(Classification Layer) . Pre-training된 모델을 불러와 NLP task를 하는데 사용할 수 있음. 크게 4가지 유형으로 구분된다. . 모델은 pre-trained parameters로 초기화 되고 각각 downstream task 별로 다른 모델이 만들어진다. 문맥을 이해하는 Language Model위에 fine-tuning 방식으로 학습되므로 적은 label 데이터로도 높은 정확도를 갖는 모델을 생성할 수 있다. . . (a), (b)는 sequence-level task, (c)와 (d)는 token-level task로 각각의 특징은 다음과 같음. . (a)는 2개 sentence를 넣고 그 관계(pair classification)를 분류하는 task임. 문장의 유사 관계 분류 등에 사용되며 (b)는 1개 sentence를 넣고 감성과 같은 문장의 특성을 분류함 . (c)는 질문(Question)과 본문(Paragraph)을 넣고 문장 단위의 답을 호출함. paragraph에서 Q와 유사도가 높은 문장을 답으로 내놓기 위해, [SEP] token 이후의 00번째 token부터 00번째 token까지를 호출함. . d)는 1개 문장을 넣고, 문장 내 token의 정보를 분류함. NER(Named Entity Recognition, 개체명 인식)이나 형태소 분석과 같이 single sentence에서 각 token이 어떤 class를 갖는지 모두 classifier 적용하여 정답을 찾아냄. .",
            "url": "https://inspiringpeople.github.io/tech_blog/2020/09/10/BERT.html",
            "relUrl": "/2020/09/10/BERT.html",
            "date": " • Sep 10, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Distilbert",
            "content": "distilbert . a distilled version of BERT: smaller, faster, cheaper and lighter . Hugging face, 2019.10 . 논문 : https://arxiv.org/abs/1910.01108 . github : https://github.com/huggingface/transformers/tree/master/examples/distillation . 해당 github에서 제안 방법으로 생성한 다른 distil* 모델 소개 (DistilGPT2, DistilRoBERTa, DistilmBERT) . abstract . 최근 pretrain -&gt; fine tuning으로 가는 방법이 많아지고 흔해졌지만, 모델 자체가 너무 크기 때문에 제한된 환경에서는 굉장히 사용하기 힘듬 | huggingface에서 DistilBert라는 general purpose language representation model 제안 | BERT를 40% 정도 줄이고 60%나 빠르게 연산하면서 97%의 성능을 유지 | . distilation (knowledge extraction) . Knowledge Distillation [Bucila et al., 2006, Hinton et al., 2015]은 larger model(teacher model)로부터 compact model(student model)을 만들어내는 방법이다. 이게 작은 모델을 바로 학습시키는 것보다 의미있는 이유는 near-zero인 확률들도 학습할 수 있기 때문이다. . 모델이 만들어낸 결과 분포가 실제 이미지를 더 풍부하게 표현한다는 것입니다. 즉, 원래 정답 관점에서는 정답 이외에 대한 정보가 없지만, 한번 모델에서 풀어나온 결과는 정답 외에도 다른 물체에 대한 정보를 담고 있게 됩니다. 이렇게 정보가 묻어 나오는 것이 마치 석유의 부산물들이 증류탑에서 나오는 양상과 같기 때문에 이를 지식 증류라고 일컫습니다. 원래 모델이 생각하는 데이터의 정보가 풀어나온 데이터로 새로 학습시키게 되면 간접적으로 선생 모델이 학습한 바를 반영하게 되므로 더 효율적으로 모델을 학습시킬 수 있으며, 새로 배우는 모델(학생 모델)은 상대적으로 더 적은 규모로 구성될 수 있습니다. 이것이 Hinton et al. 이 제시한 지식 증류의 핵심입니다. . . distilbert . architecture token-type embedding and the pooler are removed | layers is reduced by a factor of 2 variations on the last dimension of the tensor(hidden size dimension) have a smaller impact on computation efficiency) | . | . | initialization important to find the right initialization for the sub-network to converge | initialize the student from teacher by taking one layer out of two | . | distilation large batches (up to 4K) | dynamic masking without NSP | . | data and computer power same data with BERT | on 8 16GB V100 GPUs for approximately 90 hours | . | downstream benchmark 97% of performance with 40% fewer parameter comparing with BERT | . | . . distilation 방법 (github) prepare data binarize the data, i.e. tokenize the data and convert each token in an index in our model’s vocabulary | . . | training | . | . loss function 무엇? . Loss function . . Teacher 모델에서 나온 class probabilities를 바로 Student model의 target (soft target) 이용, knowledge를 효과적으로 transfer하는 방식 | MNIST를 예를 들어 2를 맞출 때 닮은 숫자인 3과 7도 낮은 확률이지만 값을 부여, 이러한 정보들은 data의 structure에 대한 정보가 들어있는 값이기 때문에 중요 정보 | 굉장히 낮은 값으로 표현되기 때문에 temperature 개념을 도입 | . | softmax-temperature . . T는 Temperature이고, T=1이라면 보통의 softmax 식 | T가 커지면 훨씬 soft한 probability distribution | T가 output distribution의 smoothness를 결정. training 동안에만 T를 조정하고 inference 시간에는 1로 설정해서 standard softmax로 사용 | . | final training loss는 distillation loss Lce와 BERT에서 사용한 Lmlm의 linear combination | Softmax(소프트맥스) . softmax는 입력받은 값을 출력으로 0~1사이의 값으로 모두 정규화하며 출력 값들의 총합은 항상 1이 되는 특성을 가진 함수 . | . distil* . distilbert는 bert-base-uncased tokenizer와 같은 tokenizer | teacher model과 비슷하게 불러오는 방식 (bert, gpt2, roberta, betlm..) | DistilBERT uncased: model = DistilBertModel.from_pretrained(&#39;distilbert-base-uncased&#39;) | DistilGPT2: model = GPT2Model.from_pretrained(&#39;distilgpt2&#39;) | DistilRoBERTa: model = RobertaModel.from_pretrained(&#39;distilroberta-base&#39;) | DistilmBERT: model = DistilBertModel.from_pretrained(&#39;distilbert-base-multilingual-cased&#39;) | . 참고 . Transformer - Harder, Better, Faster, Stronger . 🏎 Smaller, faster, cheaper, lighter: Introducing DilBERT, a distilled version of BERT . Distilling the Knowledge in a Neural Network . 📃 Distilling the Knowledge in a Neural Network 리뷰 .",
            "url": "https://inspiringpeople.github.io/tech_blog/2020/08/05/distilbert.html",
            "relUrl": "/2020/08/05/distilbert.html",
            "date": " • Aug 5, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "fastcore: An Underrated Python Library",
            "content": ". Background . I recently embarked on a journey to sharpen my python skills: I wanted to learn advanced patterns, idioms, and techniques. I started with reading books on advanced Python, however, the information didn&#39;t seem to stick without having somewhere to apply it. I also wanted the ability to ask questions from an expert while I was learning -- which is an arrangement that is hard to find! That&#39;s when it occurred to me: What if I could find an open source project that has fairly advanced python code and write documentation and tests? I made a bet that if I did this it would force me to learn everything very deeply, and the maintainers would be appreciative of my work and be willing to answer my questions. . And that&#39;s exactly what I did over the past month! I&#39;m pleased to report that it has been the most efficient learning experience I&#39;ve ever experienced. I&#39;ve discovered that writing documentation forced me to deeply understand not just what the code does but also why the code works the way it does, and to explore edge cases while writing tests. Most importantly, I was able to ask questions when I was stuck, and maintainers were willing to devote extra time knowing that their mentorship was in service of making their code more accessible! It turns out the library I choose, fastcore is some of the most fascinating Python I have ever encountered as its purpose and goals are fairly unique. . For the uninitiated, fastcore is a library on top of which many fast.ai projects are built on. Most importantly, fastcore extends the python programming language and strives to eliminate boilerplate and add useful functionality for common tasks. In this blog post, I&#39;m going to highlight some of my favorite tools that fastcore provides, rather than sharing what I learned about python. My goal is to pique your interest in this library, and hopefully motivate you to check out the documentation after you are done to learn more! . Why fastcore is interesting . Get exposed to ideas from other languages without leaving python: I’ve always heard that it is beneficial to learn other languages in order to become a better programmer. From a pragmatic point of view, I’ve found it difficult to learn other languages because I could never use them at work. Fastcore extends python to include patterns found in languages as diverse as Julia, Ruby and Haskell. Now that I understand these tools I am motivated to learn other languages. | You get a new set of pragmatic tools: fastcore includes utilities that will allow you to write more concise expressive code, and perhaps solve new problems. | Learn more about the Python programming language: Because fastcore extends the python programming language, many advanced concepts are exposed during the process. For the motivated, this is a great way to see how many of the internals of python work. | A whirlwind tour through fastcore . Here are some things you can do with fastcore that immediately caught my attention. . . Making **kwargs transparent . Whenever I see a function that has the argument **kwargs, I cringe a little. This is because it means the API is obfuscated and I have to read the source code to figure out what valid parameters might be. Consider the below example: . def baz(a, b=2, c =3, d=4): return a + b + c def foo(c, a, **kwargs): return c + baz(a, **kwargs) inspect.signature(foo) . &lt;Signature (c, a, **kwargs)&gt; . Without reading the source code, it might be hard for me to know that foo also accepts and additional parameters b and d. We can fix this with delegates: . def baz(a, b=2, c =3, d=4): return a + b + c @delegates(baz) # this decorator will pass down keyword arguments from baz def foo(c, a, **kwargs): return c + baz(a, **kwargs) inspect.signature(foo) . &lt;Signature (c, a, b=2, d=4)&gt; . You can customize the behavior of this decorator. For example, you can have your cake and eat it too by passing down your arguments and also keeping **kwargs: . @delegates(baz, keep=True) def foo(c, a, **kwargs): return c + baz(a, **kwargs) inspect.signature(foo) . &lt;Signature (c, a, b=2, d=4, **kwargs)&gt; . You can also exclude arguments. For example, we exclude argument d from delegation: . def basefoo(a, b=2, c =3, d=4): pass @delegates(basefoo, but= [&#39;d&#39;]) # exclude `d` def foo(c, a, **kwargs): pass inspect.signature(foo) . &lt;Signature (c, a, b=2)&gt; . You can also delegate between classes: . class BaseFoo: def __init__(self, e, c=2): pass @delegates()# since no argument was passsed here we delegate to the superclass class Foo(BaseFoo): def __init__(self, a, b=1, **kwargs): super().__init__(**kwargs) inspect.signature(Foo) . &lt;Signature (a, b=1, c=2)&gt; . For more information, read the docs on delegates. . . Avoid boilerplate when setting instance attributes . Have you ever wondered if it was possible to avoid the boilerplate involved with setting attributes in __init__? . class Test: def __init__(self, a, b ,c): self.a, self.b, self.c = a, b, c . Ouch! That was painful. Look at all the repeated variable names. Do I really have to repeat myself like this when defining a class? Not Anymore! Checkout store_attr: . class Test: def __init__(self, a, b, c): store_attr() t = Test(5,4,3) assert t.b == 4 . You can also exclude certain attributes: . class Test: def __init__(self, a, b, c): store_attr(but=[&#39;c&#39;]) t = Test(5,4,3) assert t.b == 4 assert not hasattr(t, &#39;c&#39;) . There are many more ways of customizing and using store_attr than I highlighted here. Check out the docs for more detail. . . Avoiding subclassing boilerplate . One thing I hate about python is the __super__().__init__() boilerplate associated with subclassing. For example: . class ParentClass: def __init__(self): self.some_attr = &#39;hello&#39; class ChildClass(ParentClass): def __init__(self): super().__init__() cc = ChildClass() assert cc.some_attr == &#39;hello&#39; # only accessible b/c you used super . We can avoid this boilerplate by using the metaclass PrePostInitMeta. We define a new class called NewParent that is a wrapper around the ParentClass: . class NewParent(ParentClass, metaclass=PrePostInitMeta): def __pre_init__(self, *args, **kwargs): super().__init__() class ChildClass(NewParent): def __init__(self):pass sc = ChildClass() assert sc.some_attr == &#39;hello&#39; . . Type Dispatch . Type dispatch, or Multiple dispatch, allows you to change the way a function behaves based upon the input types it receives. This is a prominent feature in some programming languages like Julia. For example, this is a conceptual example of how multiple dispatch works in Julia, returning different values depending on the input types of x and y: . collide_with(x::Asteroid, y::Asteroid) = ... # deal with asteroid hitting asteroid collide_with(x::Asteroid, y::Spaceship) = ... # deal with asteroid hitting spaceship collide_with(x::Spaceship, y::Asteroid) = ... # deal with spaceship hitting asteroid collide_with(x::Spaceship, y::Spaceship) = ... # deal with spaceship hitting spaceship . Type dispatch can be especially useful in data science, where you might allow different input types (i.e. Numpy arrays and Pandas dataframes) to a function that processes data. Type dispatch allows you to have a common API for functions that do similar tasks. . Unfortunately, Python does not support this out-of-the box. Fortunately, there is the @typedispatch decorator to the rescue. This decorator relies upon type hints in order to route inputs the correct version of the function: . @typedispatch def f(x:str, y:str): return f&#39;{x}{y}&#39; @typedispatch def f(x:np.ndarray): return x.sum() @typedispatch def f(x:int, y:int): return x+y . Below is a demonstration of type dispatch at work for the function f: . f(&#39;Hello &#39;, &#39;World!&#39;) . &#39;Hello World!&#39; . f(2,3) . 5 . f(np.array([5,5,5,5])) . 20 . There are limitations of this feature, as well as other ways of using this functionality that you can read about here. In the process of learning about typed dispatch, I also found a python library called multipledispatch made by Mathhew Rocklin (the creator of Dask). . After using this feature, I am now motivated to learn languages like Julia to discover what other paradigms I might be missing. . . A better version of functools.partial . functools.partial is a great utility that creates functions from other functions that lets you set default values. Lets take this function for example that filters a list to only contain values &gt;= val: . test_input = [1,2,3,4,5,6] def f(arr, val): &quot;Filter a list to remove any values that are less than val.&quot; return [x for x in arr if x &gt;= val] f(test_input, 3) . [3, 4, 5, 6] . You can create a new function out of this function using partial that sets the default value to 5: . filter5 = partial(f, val=5) filter5(test_input) . [5, 6] . One problem with partial is that it removes the original docstring and replaces it with a generic docstring: . filter5.__doc__ . &#39;partial(func, *args, **keywords) - new function with partial application n of the given arguments and keywords. n&#39; . fastcore.utils.partialler fixes this, and makes sure the docstring is retained such that the new API is transparent: . filter5 = partialler(f, val=5) filter5.__doc__ . &#39;Filter a list to remove any values that are less than val.&#39; . . Composition of functions . A technique that is pervasive in functional programming languages is function composition, whereby you chain a bunch of functions together to achieve some kind of result. This is especially useful when applying various data transformations. Consider a toy example where I have three functions: (1) Removes elements of a list less than 5 (from the prior section) (2) adds 2 to each number (3) sums all the numbers: . def add(arr, val): return [x + val for x in arr] def arrsum(arr): return sum(arr) # See the previous section on partialler add2 = partialler(add, val=2) transform = compose(filter5, add2, arrsum) transform([1,2,3,4,5,6]) . 15 . But why is this useful? You might me thinking, I can accomplish the same thing with: . arrsum(add2(filter5([1,2,3,4,5,6]))) . You are not wrong! However, composition gives you a convenient interface in case you want to do something like the following: . def fit(x, transforms:list): &quot;fit a model after performing transformations&quot; x = compose(*transforms)(x) y = [np.mean(x)] * len(x) # its a dumb model. Don&#39;t judge me return y # filters out elements &lt; 5, adds 2, then predicts the mean fit(x=[1,2,3,4,5,6], transforms=[filter5, add2]) . [7.5, 7.5] . For more information about compose, read the docs. . . A more useful __repr__ . In python, __repr__ helps you get information about an object for logging and debugging. Below is what you get by default when you define a new class. (Note: we are using store_attr, which was discussed earlier). . class Test: def __init__(self, a, b=2, c=3): store_attr() # `store_attr` was discussed previously Test(1) . &lt;__main__.Test at 0x7fe0ab662790&gt; . We can use basic_repr to quickly give us a more sensible default: . class Test: def __init__(self, a, b=2, c=3): store_attr() __repr__ = basic_repr(&#39;a,b,c&#39;) Test(2) . Test(a=2, b=2, c=3) . . Monkey Patching With A Decorator . It can be convenient to monkey patch with a decorator, which is especially helpful when you want to patch an external library you are importing. We can use the decorator @patch from fastcore.foundation along with type hints like so: . class MyClass(int): pass @patch def func(self:MyClass, a): return self+a mc = MyClass(3) . Now, MyClass has an additional method named func: . mc.func(10) . 13 . Still not convinced? I&#39;ll show you another example of this kind of patching in the next section. . . A better pathlib.Path . When you see these extensions to pathlib.path you won&#39;t ever use vanilla pathlib again! A number of additional methods have been added to pathlib, such as: . Path.readlines: same as with open(&#39;somefile&#39;, &#39;r&#39;) as f: f.readlines() | Path.read: same as with open(&#39;somefile&#39;, &#39;r&#39;) as f: f.read() | Path.save: saves file as pickle | Path.load: loads pickle file | Path.ls: shows the contents of the path as a list. | etc. | . Read more about this here. Here is a demonstration of ls: . from pathlib import Path p = Path(&#39;../_notebooks&#39;) p.ls() # you don&#39;t get this with vanilla Pathlib.Path!! . (#21) [Path(&#39;../_notebooks/gpt2_simple_mask.jpg&#39;),Path(&#39;../_notebooks/bert_mac_small.jpg&#39;),Path(&#39;../_notebooks/causal_with_prefix.jpg&#39;),Path(&#39;../_notebooks/.DS_Store&#39;),Path(&#39;../_notebooks/2020-03-07-How_to_Create_an_Automatic_Code_Comment_Generator_using_Deep_Learning.ipynb&#39;),Path(&#39;../_notebooks/2020-09-01-fastcore.ipynb&#39;),Path(&#39;../_notebooks/2020-03-07-Syntax-Highlighting.ipynb&#39;),Path(&#39;../_notebooks/2020-03-06-bart.ipynb&#39;),Path(&#39;../_notebooks/README.md&#39;),Path(&#39;../_notebooks/2020-05-01-TrainDonkeyCar.ipynb&#39;)...] . Wait! What&#39;s going on here? We just imported pathlib.Path - why are we getting this new functionality? Thats because we imported the fastcore.foundation module, which patches this module via the @patch decorator discussed earlier. Just to drive the point home on why the @patch decorator is useful, I&#39;ll go ahead and add another method to Path right now: . @patch def fun(self:Path): return &quot;This is fun!&quot; p.fun() . &#39;This is fun!&#39; . That is magical, right? I know! That&#39;s why I&#39;m writing about it! . . An Even More Concise Way To Create Lambdas . Self, with an uppercase S, is an even more concise way to create lambdas that are calling methods on an object. For example, let&#39;s create a lambda for taking the sum of a Numpy array: . arr=np.array([5,4,3,2,1]) f = lambda a: a.sum() assert f(arr) == 15 . You can use Self in the same way: . f = Self.sum() assert f(arr) == 15 . Let&#39;s create a lambda that does a groupby and max of a Pandas dataframe: . import pandas as pd df=pd.DataFrame({&#39;Some Column&#39;: [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, ], &#39;Another Column&#39;: [5, 7, 50, 70]}) f = Self.groupby(&#39;Some Column&#39;).mean() f(df) . Another Column . Some Column . a 6 | . b 60 | . Read more about Self in the docs). . . Notebook Functions . These are simple but handy, and allow you to know whether or not code is executing in a Jupyter Notebook, Colab, or an Ipython Shell: . in_notebook(), in_colab(), in_ipython() . (True, False, True) . This is useful if you are displaying certain types of visualizations, progress bars or animations in your code that you may want to modify or toggle depending on the environment. . . A Drop-In Replacement For List . You might be pretty happy with Python&#39;s list. This is one of those situations that you don&#39;t know you needed a better list until someone showed one to you. Enter L, a list like object with many extra goodies. . The best way I can describe L is to pretend that list and numpy had a pretty baby: . define a list (check out the nice __repr__ that shows the length of the list!) . L(1,2,3) . (#3) [1,2,3] . Shuffle a list: . p = L.range(20).shuffle() p . (#20) [2,0,18,6,15,17,14,8,12,1...] . Index into a list: . p[2,4,6] . (#3) [18,15,14] . L has sensible defaults, for example appending an element to a list: . 1 + L(2,3,4) . (#4) [1,2,3,4] . There is much more L has to offer. Read the docs to learn more. . But Wait ... There&#39;s More! . There are more things I would like to show you about fastcore, but there is no way they would reasonably fit into a blog post. Here is a list of some of my favorite things that I didn&#39;t demo in this blog post: . Utilities . The Utilites section contain many shortcuts to perform common tasks or provide an additional interface to what standard python provides. . mk_class: quickly add a bunch of attributes to a class | wrap_class: add new methods to a class with a simple decorator | groupby: similar to Scala&#39;s groupby | merge: merge dicts | fasttuple: a tuple on steroids | Infinite Lists: useful for padding and testing | chunked: for batching and organizing stuff | . Multiprocessing . The Multiprocessing section extends python&#39;s multiprocessing library by offering features like: . progress bars | ability to pause to mitigate race conditions with external services | processing things in batches on each worker, ex: if you have a vectorized operation to perform in chunks | . Functional Programming . The functional programming section is my favorite part of this library. . maps: a map that also composes functions | mapped: A more robust map | using_attr: compose a function that operates on an attribute | . Transforms . Transforms is a collection of utilities for creating data transformations and associated pipelines. These transformation utilities build upon many of the building blocks discussed in this blog post. . Further Reading . It should be noted that you should read the main page of the docs first, followed by the section on tests to fully understand the documentation. . The fastcore documentation site. | The fastcore GitHub repo. | Blog post on delegation. | . Shameless plug: fastpages . This blog post was written entirely in a Jupyter Notebook, which GitHub automatically converted into to a blog post! Sound interesting? Check out fastpages. .",
            "url": "https://inspiringpeople.github.io/tech_blog/fastcore/",
            "relUrl": "/fastcore/",
            "date": " • Jan 1, 2019"
        }
        
    
  
    
        ,"post3": {
            "title": "Ground Rules",
            "content": "facebook fast.ai 그룹 몇몇 분들과 함께 fastbook 스터디를 하게 되었다. fastbook은 fast.ai와 pytorch를 이용한 딥러닝 내용과 예제가 ipynb 형식으로 구성되어 있다. paper도 구매 가능하지만 draft fastbook도 공개되어 있다. . fast.ai로 transformer 프로젝트를 해 본 결과 빠르게 프로토타이핑 해볼 수 있다는 장점과 연구자들이 항상 목말라하던 여러가지 실험에 대해 다양한 지원을 해주는 것을 보고 깊게 들여다보고 싶은 마음이 있었는데, 이렇게 좋은 계기가 생겨 스터디 후 그 기록을 블로그에 남기기로 한다. . 지금 글을 쓰고 있는 이 블로그 페이지도 fast.ai의 fastpages라는 기술로 만든 것인데, 몇 분이면 뚝딱 블로그를 만들 수 있고, technical writing까지 편하게 ipynb, word, markdown 등 여러 타입의 문서를 호환하여 사용할 수 있다. 자세한 설명은 박찬성님의 이 링크에서 확인할 수 있다. . fastbook study에 대한 내용을 앞으로 업데이트 할 예정인데, 꾸준한 글쓰기를 위해 다음과 같은 Grould rules를 두었다. . 각 내용에서 중요 부분은 bold 표시! | 모든 내용에 대한 설명을 쓰기보다는 (이미 자세한 설명과 예제는 fastbook이 공개되어 있으므로..) 각 챕터를 통해 배운 내용, takeaway 부분을 요약적으로 정리한다. | 각 내용에 대한 reference 부분, try&amp;error 등을 추가적으로 기입한다. | 그럼 기록 모드 다시 on! Done is Better than Perfect! .",
            "url": "https://inspiringpeople.github.io/tech_blog/note/2018/08/30/rules.html",
            "relUrl": "/note/2018/08/30/rules.html",
            "date": " • Aug 30, 2018"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "달리기를 말할 때 내가 하고 싶은 이야기 (무라카미하루키) 중에서 . [발췌] . 강물을 생각하려 한다. 구름을 생각하려 한다. 나는 소박하고 아담한 공백 속을, 정겨운 침묵 속을 그저 계속 달려가고 있다. 그 누가 뭐라고 해도, 그것은 여간 멋진 일이 아니다. . 계속 하는 것-리듬을 단절 하지 않는 것, 장기적인 작업을 하는 데에는 그것이 중요하다. 일단 리듬이 설정되어지기만 하면, 그 뒤는 어떻게든 풀려 나간다. 그러나 탄력을 받은 바퀴가 일정한 속도로 확실하게 돌아가기 시작할 때까지는 계속 가속하는 힘을 멈추지 말아야 한다는 것은 아무리 주의를 기울인다고 해도 지나치지 않다. . 달리는 것은, 내가 이제까지의 인생을 사는 가운데 후천적으로 익혔던 몇 가지 습관 중에서 아마도 가장 유익하고 중요한 의미를 지닌 것이라고 생각된다. … 물론 나라고 해서 지는 걸 좋아할 리는 없다. 그러나 왠지 모르게 다른 사람을 상대로 이기거나 지거나 하는 경기에 대해서는 옛날부터 한결같이 그다지 연연하지 않았다. 그러한 성향은 어른이 된 뒤에도 대체로 변하지 않는다. 어떤 일이 됐든 다른 사람을 상대로 이기든 지든 그다지 신경 쓰지 않는다. 그보다는 나 자신이 설정한 기준을 만족시킬 수 있는가 없는가에 더 관심이 쏠린다. 그런 의미에서 장거리를 달리는 것은 나의 성격에 아주 잘 맞는 스포츠였다. …다시 말하면 끝까지 달리고 나서 자신에 대한 자부심(혹은 프라이드와 비슷한 것)을 가질 수 있는가 없는가, 그것이 장거리 러너에게 있어서의 중요한 기준이 된다…. 그런 의미에서 소설을 쓰는 것은 마라톤 풀코스를 뛰는 것과 비슷하다. 기본적인 원칙을 말한다면, 창작자에게 있어 그 동기는 자신 안에 조용히 확실하게 존재하는 것으로서, 외부에서 어떤 형태나 기준을 찾아야 할 일은 아니다. . 달린다는 것은 나에게 있어 유익한 운동인 동시에 유효한 메타포이기도 하다. … 어제의 자신이 지닌 약점을 조금이라도 극복해나가는 것, 그것이 더 중요한 것이다. 장거리 달리기에 있어서 이겨내야 할 상대가 있다면, 그것은 바로 과거의 자기 자신이기 때문이다. . 나이를 먹어간다는 것은 태어나서 처음으로 체험하는 것이고, 거기에서 느끼는 감정 역시 처음으로 맛보는 감정인 것이다. …그러나 나이를 먹어감에 따라, 그와 같은 괴로움이나 상처는 인생에 있어 어느 정도 필요한 것이다, 라는 점을 조금씩 깨닫게 되었다. 생각해보면 타인과 얼마간이나마 차이가 있는 것이야말로, 사람의 자아란 것을 형성하게 되고, 자립한 인간으로서의 모습을 유지해갈 수 있도록 만드는 것이다. … 내가 다른 누구도 아닌 ‘나’라는 것은, 나에게 있어 하나의 소중한 자산인 것이다. 마음이 받게 되는 아픈 상처는 그와 같은 인간의 자립성이 세계에 대해 지불하지 않으면 안 될 당연한 대가인것이다. . 타인으로부터의 고립과 단절은 병에서 새어 나온 신처럼 알지 못하는 사이에 사람의 마음을 갉아먹고 녹여버린다. 그것은 양날의 검과 같은 것이다. 사람의 마음을 보호하는 동시에, 그 내벽을 끊임없이 자잘하게 상처 내기도 한다. … 나는 신체를 끊임없이 물리적으로 움직여 나감으로써, 어떤 경우에는 극한으로까지 몰아감으로써, 내면에 안고 있는 고립과 단절의 느낌을 치유하고 객관화해 나가야 했던 것이다. 의도적이라기보다는 오히려 직감적으로. .",
          "url": "https://inspiringpeople.github.io/tech_blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://inspiringpeople.github.io/tech_blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}