{
  
    
        "post0": {
            "title": "NSMC Review, 2 Label, Korean",
            "content": "from fine_tuning3 import * from inference3 import * . fastai version : 1.0.60 transformers version : 2.11.0 . distilbert-base-uncased . select : . data_name = &#39;nsmc_ko_2label&#39; model_type = &#39;distilbert&#39; pretrained_model_name = &#39;distilbert-base-multilingual-cased&#39; finetuned_model_name = &#39;/home/jovyan/AI_Master/Flex_NLP/models/test/&#39; + data_name + &#39;_&#39; + pretrained_model_name + &#39;.pkl&#39; train, test, n_label, doc_name, label_name = get_data(data_name) tokenizer_class, custom_transformer_model = load_pretrained_model(model_type, pretrained_model_name, n_label) databunch = proc_tokenize(tokenizer_class, train, doc_name, label_name, pretrained_model_name) export_learner = test_fine_tuned(custom_transformer_model, databunch, [2e-05, 3e-05, 5e-05]) . (119996, 3) get_data function took 0.15944170951843262 sec load_pretrained_model function took 3.3323235511779785 sec . proc_tokenize function took 18.300304412841797 sec . epoch train_loss valid_loss accuracy error_rate time . 0 | 0.398963 | 0.391055 | 0.817735 | 0.182265 | 05:10 | . 1 | 0.334558 | 0.334869 | 0.854405 | 0.145595 | 05:18 | . 2 | 0.249058 | 0.321950 | 0.858572 | 0.141428 | 05:23 | . 3 | 0.187086 | 0.362457 | 0.860155 | 0.139845 | 05:32 | . epoch train_loss valid_loss accuracy error_rate time . 0 | 0.160463 | 0.484256 | 0.849904 | 0.150096 | 05:29 | . 1 | 0.177780 | 0.439866 | 0.849904 | 0.150096 | 05:24 | . 2 | 0.133438 | 0.441068 | 0.858738 | 0.141262 | 05:26 | . 3 | 0.106280 | 0.518960 | 0.859572 | 0.140428 | 05:34 | . epoch train_loss valid_loss accuracy error_rate time . 0 | 0.111478 | 0.480683 | 0.844487 | 0.155513 | 05:30 | . 1 | 0.178645 | 0.512187 | 0.843987 | 0.156013 | 05:24 | . 2 | 0.122143 | 0.498857 | 0.849071 | 0.150929 | 05:25 | . 3 | 0.070788 | 0.573300 | 0.856488 | 0.143512 | 05:33 | . test_fine_tuned function took 3917.859872817993 sec . # epoch = 3 # lr = 2e-05 # export_learner = save_fine_tuned(custom_transformer_model, databunch, epoch, lr, finetuned_model_name) export_learner[0].export(file=finetuned_model_name) # selected_learner = load_fine_tuned_model(databunch, custom_transformer_model, finetuned_model_name) preds, preds_sentiment = get_nsmc_prediction_result(export_learner[0], test[&#39;document&#39;]) get_accuracy(list(test[&#39;label&#39;]), preds_sentiment) . epoch train_loss valid_loss accuracy error_rate time . 0 | 0.024498 | 0.675273 | 0.851238 | 0.148762 | 05:28 | . 1 | 0.040041 | 0.770852 | 0.856571 | 0.143429 | 05:24 | . 2 | 0.029628 | 0.797422 | 0.856905 | 0.143095 | 05:25 | . save_fine_tuned function took 978.441011428833 sec tensor([[ 101, 10003, 119, ..., 119, 119, 102], [ 101, 19709, 71439, ..., 0, 0, 0], [ 101, 107, 8996, ..., 0, 0, 0], ..., [ 101, 8924, 37388, ..., 0, 0, 0], [ 101, 9568, 12310, ..., 0, 0, 0], [ 101, 10028, 27023, ..., 0, 0, 0]]) . get_nsmc_prediction_result function took 147.09131717681885 sec 85.80619353978466 test . bert-base-multilingual-cased . select : . data_name = &#39;nsmc_ko_2label&#39; model_type = &#39;bert&#39; pretrained_model_name = &#39;bert-base-multilingual-cased&#39; finetuned_model_name = &#39;/home/jovyan/AI_Master/Flex_NLP/models/test/&#39; + data_name + &#39;_&#39; + pretrained_model_name + &#39;.pkl&#39; train, test, n_label, doc_name, label_name = get_data(data_name) tokenizer_class, custom_transformer_model = load_pretrained_model(model_type, pretrained_model_name, n_label) databunch = proc_tokenize(tokenizer_class, train, doc_name, label_name, pretrained_model_name) export_learner = test_fine_tuned(custom_transformer_model, databunch, [2e-05, 3e-05, 5e-05]) . (119996, 3) get_data function took 0.32505083084106445 sec load_pretrained_model function took 11.704046964645386 sec . proc_tokenize function took 25.048545122146606 sec . epoch train_loss valid_loss accuracy error_rate time . 0 | 0.367068 | 0.351228 | 0.847821 | 0.152179 | 17:25 | . 1 | 0.329095 | 0.322921 | 0.863405 | 0.136595 | 17:37 | . 2 | 0.227537 | 0.319260 | 0.872573 | 0.127427 | 17:45 | . 3 | 0.168935 | 0.360286 | 0.868989 | 0.131011 | 17:47 | . epoch train_loss valid_loss accuracy error_rate time . 0 | 0.179047 | 0.476871 | 0.856405 | 0.143595 | 17:55 | . 1 | 0.194444 | 0.434226 | 0.855655 | 0.144345 | 17:27 | . 2 | 0.122906 | 0.437409 | 0.865989 | 0.134011 | 17:18 | . 3 | 0.111035 | 0.466713 | 0.868656 | 0.131344 | 17:47 | . &lt;progress value=&#39;0&#39; class=&#39;&#39; max=&#39;4&#39;, style=&#39;width:300px; height:20px; vertical-align: middle;&#39;&gt;&lt;/progress&gt; 0.00% [0/4 00:00&lt;00:00] epoch train_loss valid_loss accuracy error_rate time . &lt;progress value=&#39;5633&#39; class=&#39;&#39; max=&#39;6749&#39;, style=&#39;width:300px; height:20px; vertical-align: middle;&#39;&gt;&lt;/progress&gt; 83.46% [5633/6749 14:27&lt;02:51 0.1220] &lt;/div&gt; &lt;/div&gt; RuntimeError Traceback (most recent call last) &lt;ipython-input-3-e4008ee58cae&gt; in &lt;module&gt; 8 tokenizer_class, custom_transformer_model = load_pretrained_model(model_type, pretrained_model_name, n_label) 9 databunch = proc_tokenize(tokenizer_class, train, doc_name, label_name, pretrained_model_name) &gt; 10 export_learner = test_fine_tuned(custom_transformer_model, databunch, [2e-05, 3e-05, 5e-05]) ~/AI_Master/Flex_NLP/utils.py in wrapper(*args, **kwargs) 8 def wrapper(*args, **kwargs): 9 t1 = time.time() &gt; 10 result = original_function(*args, **kwargs) 11 t2 = time.time() - t1 12 print(&#39;{} function took {} sec&#39;.format(original_function.__name__, t2)) ~/AI_Master/Flex_NLP/fine_tuning3.py in test_fine_tuned(custom_transformer_model, databunch, lr_list) 158 seed_all(seed_val) 159 --&gt; 160 learner.fit_one_cycle(4,max_lr=l) 161 learner_list.append(learner) 162 ~/conda/lib/python3.7/site-packages/fastai/train.py in fit_one_cycle(learn, cyc_len, max_lr, moms, div_factor, pct_start, final_div, wd, callbacks, tot_epochs, start_epoch) 21 callbacks.append(OneCycleScheduler(learn, max_lr, moms=moms, div_factor=div_factor, pct_start=pct_start, 22 final_div=final_div, tot_epochs=tot_epochs, start_epoch=start_epoch)) &gt; 23 learn.fit(cyc_len, max_lr, wd=wd, callbacks=callbacks) 24 25 def fit_fc(learn:Learner, tot_epochs:int=1, lr:float=defaults.lr, moms:Tuple[float,float]=(0.95,0.85), start_pct:float=0.72, ~/conda/lib/python3.7/site-packages/fastai/basic_train.py in fit(self, epochs, lr, wd, callbacks) 198 else: self.opt.lr,self.opt.wd = lr,wd 199 callbacks = [cb(self) for cb in self.callback_fns + listify(defaults.extra_callback_fns)] + listify(callbacks) --&gt; 200 fit(epochs, self, metrics=self.metrics, callbacks=self.callbacks+callbacks) 201 202 def create_opt(self, lr:Floats, wd:Floats=0.)-&gt;None: ~/conda/lib/python3.7/site-packages/fastai/basic_train.py in fit(epochs, learn, callbacks, metrics) 99 for xb,yb in progress_bar(learn.data.train_dl, parent=pbar): 100 xb, yb = cb_handler.on_batch_begin(xb, yb) --&gt; 101 loss = loss_batch(learn.model, xb, yb, learn.loss_func, learn.opt, cb_handler) 102 if cb_handler.on_batch_end(loss): break 103 ~/conda/lib/python3.7/site-packages/fastai/basic_train.py in loss_batch(model, xb, yb, loss_func, opt, cb_handler) 32 if opt is not None: 33 loss,skip_bwd = cb_handler.on_backward_begin(loss) &gt; 34 if not skip_bwd: loss.backward() 35 if not cb_handler.on_backward_end(): opt.step() 36 if not cb_handler.on_step_end(): opt.zero_grad() ~/conda/lib/python3.7/site-packages/torch/tensor.py in backward(self, gradient, retain_graph, create_graph) 193 products. Defaults to ``False``. 194 &#34;&#34;&#34; --&gt; 195 torch.autograd.backward(self, gradient, retain_graph, create_graph) 196 197 def register_hook(self, hook): ~/conda/lib/python3.7/site-packages/torch/autograd/__init__.py in backward(tensors, grad_tensors, retain_graph, create_graph, grad_variables) 97 Variable._execution_engine.run_backward( 98 tensors, grad_tensors, retain_graph, create_graph, &gt; 99 allow_unreachable=True) # allow_unreachable flag 100 101 RuntimeError: CUDA out of memory. Tried to allocate 20.00 MiB (GPU 0; 7.93 GiB total capacity; 7.14 GiB already allocated; 3.31 MiB free; 7.43 GiB reserved in total by PyTorch) . &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; data_name = &#39;nsmc_ko_2label&#39; model_type = &#39;bert&#39; pretrained_model_name = &#39;bert-base-multilingual-cased&#39; finetuned_model_name = &#39;/home/jovyan/AI_Master/Flex_NLP/models/test/&#39; + data_name + &#39;_&#39; + pretrained_model_name + &#39;.pkl&#39; train, test, n_label, doc_name, label_name = get_data(data_name) tokenizer_class, custom_transformer_model = load_pretrained_model(model_type, pretrained_model_name, n_label) databunch = proc_tokenize(tokenizer_class, train, doc_name, label_name, pretrained_model_name) epoch = 3 lr = 2e-05 export_learner = save_fine_tuned(custom_transformer_model, databunch, epoch, lr, finetuned_model_name) export_learner.export(file=finetuned_model_name) selected_learner = load_fine_tuned_model(databunch, custom_transformer_model, finetuned_model_name) preds, preds_sentiment = get_nsmc_prediction_result(selected_learner, test[&#39;document&#39;]) get_accuracy(list(test[&#39;label&#39;]), preds_sentiment) . (119996, 3) get_data function took 0.28765201568603516 sec load_pretrained_model function took 10.67808985710144 sec . proc_tokenize function took 16.9791738986969 sec . epoch train_loss valid_loss accuracy error_rate time . 0 | 0.363148 | 0.355757 | 0.850738 | 0.149262 | 08:47 | . 1 | 0.307106 | 0.324662 | 0.861572 | 0.138428 | 09:17 | . 2 | 0.203433 | 0.322358 | 0.869989 | 0.130011 | 09:32 | . save_fine_tuned function took 1665.0687637329102 sec tensor([[ 101, 10003, 119, ..., 119, 119, 102], [ 101, 19709, 71439, ..., 0, 0, 0], [ 101, 107, 8996, ..., 0, 0, 0], ..., [ 101, 8924, 37388, ..., 0, 0, 0], [ 101, 9568, 12310, ..., 0, 0, 0], [ 101, 10028, 27023, ..., 0, 0, 0]]) . get_nsmc_prediction_result function took 240.79188680648804 sec 86.96623220774026 test . &lt;/div&gt; .",
            "url": "https://inspiringpeople.github.io/tech_blog/2020/09/10/nsmc_test_fine_tuned.html",
            "relUrl": "/2020/09/10/nsmc_test_fine_tuned.html",
            "date": " • Sep 10, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Bert",
            "content": "BERT . By Google (2018.10 논문이 공개, 11월에 오픈 소스로 공개 됨) . | BERT는 Bidirectional Encoder Representations from Transformers . | “Attention is all you need” (2017년 논문)에서 소개한 Transformer의 Encoder 부분 사용 . | Github : https://github.com/google-research/bert . | Paper : https://arxiv.org/abs/1810.04805 . | . . [Transformer Architecture] . 1) Transformer Encoder . 2) Transformer Decoder . Bert에서는 Transformer의 Encoder Block만을 사용 . Bert base 모델은 Encoder Block을 12개, Bert large 모델은 24개 쌓아서 만듬. . (Transformer의 Decoder Block을 쓰는 모델은 GPT 계열 모델, Encoder / Decoder Block을 모두 쓰는 모델은 T5 등이 있다) . 주요 개념 . Bert의 자세한 내용을 살펴보기 전에, Bert를 이해하기 위한 주요 개념들에 대해 소개한다. . Transfer Learning . . 패러다임의 전환! . BERT는 기본적으로, wiki나 book data와 같은 대용량 unlabeled data로 모델을 미리 학습 시킨 후, 특정 task를 가지고 있는 labeled data로 transfer learning을 하는 모델이다. 이때 unlabeled data로 학습하는 과정을 pre-training (upstream task), labeled data로 학습하는 과정을 fine-tuning (downstream task)라고 지칭한다. | . . Bert의 Pre-training / Fine-tuning . Bert는 wiki, book corpus 데이터로 pre-training을 수행하여 General purpose의 언어모델 (Language Model)을 학습하고, 다양한 task에 따라 (Glue, Super Glue 등) fine-tuning 모델을 생성하는 방식이다. 이로써 적은 labeling data로도 SOTA 모델을 만들 수 있다. . Language Model은 어떤 방식으로 문맥을 학습할까? (Transformer 계열 모델) . Attention . Attention이란? . 인간은 정보처리를 할 때 모든 sequence를 고려하지 않음. 찾아야 하는 주요 정보가 무엇인지 알 수 있다면 이에 가중치를 주어, 주요 정보를 중심으로 맥락을 파악할 수 있음. Attention의 모티브는 자신에게 의미 있는 feature만 골라내서 중요하게 판단하겠다는 것임. . 논문 : Neural Machine Translation by Jointly Learning to Align and Translate (https://arxiv.org/abs/1409.0473), 조경현 교수님 . | 어텐션 매커니즘은 기계번역(machine translation)을 위한 sequence-to-sequence 모델(S2S)에 처음 도입 . | 번역 시 소스랭귀지와 타겟랭귀지의 길이가 길어질 수록 모델의 성능이 나빠짐, 이를 방지하기 위해 모델로 하여금 ‘중요한 부분만 집중(attention)하게 만들자’는 것이 어텐션 매커니즘의 핵심 아이디어 . | 어텐션은 weights의 중요도 벡터, 이미지의 픽셀값이나 문장에서 단어 등 어떤 요소를 예측하거나 추정하기 위해, 다른 요소들과 얼마나 강하게 연관되어 있는지 확인하고 어텐션 백터로 가중 합산된 값의 합계를 타겟값으로 추정 . | . Input 중에서 무엇이 중요한지는 attention weight로 학습이 가능하며, input과 output이 어떻게 연결되어 있는지 시각화가 가능함. (어떤 feature들이 연결되어 있는지 알 수 있음) . . 기존 Attention 방식의 단점 . 번역모델(Seq2Seq) Attention 메커니즘의 핵심은 decoder의 특정 time-step의 output이 encoder의 모든 time-step의 output 중 어떤 time-step과 가장 연관이 있는가임. 일반적인 Seq2Seq-Attention 모델에서의 번역 태스크의 문제는 원본 언어(Source Language), 번역된 언어(Target Language)간의 대응 여부는 Attention을 통해 찾을 수 있었음. (input 나는 소년이다 &lt;-&gt; output I am a boy 간에 ‘나’ 와 ‘I’, ‘소년’과 ‘boy’의 대응관계) . | 그러나 각 문장에서의 관계를 나타낼 수 없음. ‘I love tiger but it is scare’에서 ‘it’이 무엇을 나타내는지 와 같은 문제는 기존 Encoder-Decoder 기반의 Attention메커니즘에서는 찾을 수 없었음. . | Attention 모델은 Seq2seq의 성능을 높였으나, RNN이 순차로 이뤄져 연산이 느리다는 구조적인 문제점이 있음. 또한 병렬처리가 불가능함. 이런 단점을 해결하기 위해 RNN을 없애는 아이디어가 나오게 됨. . | . Self-attention . Self-attention이란? . 2017년 구글이 발표한 논문인 “Attention is all you need” (https://papers.nips.cc/paper/7181-attention-is-all-you-need.pdf)에서 제안된 transformer model에서 소개된 방법 . | 기존의 seq2seq의 구조인 인코더-디코더 따르면서도 순환신경만 기반으로 구성된 기존 모델과 다르게 단순히 어텐션 구조만으로 전체 모델을 만들어 어텐션 기법의 중요성을 강조 . | 문장 내에서 token들이 스스로를 잘 표현하는 context vector를 갖게 만듦. . | . . 밑줄 친 부분에 따라 it에 대한 가중치가 달라짐 . Bert has multi-head attention : Bert is multi-headed beast! . Bert base 모델의 경우 Layer 12, attention head 12개 architecture를 가지고 있다. . | 따라서 12*12 = 144, 144개의 distinct attention을 갖게 됨 . | . . L2, H0: Attention to next word . . L6, H11: Attention to previous word . . L2, H1: Attention to other words predictive of word . 기존의 word2vec 같은 경우 하나의 단어는 하나의 vector 값만을 표현하였지만, transformer 계열 모델의 경우 multi-headed attention을 이용함으로써 하나의 단어가 여러 개의 “representation 공간”을 가질 수 있게 됨. . 2. Pre-training . Bert의 pre-training 과정은 크게 Input Embedding, MLM, NSP 3가지 과정으로 나눠진다. . Pre-training data (BERT base) . BookCorpus (Zhu et al., 2015) (800M words) + English Wikipedia (2,500M words) . | Unsupervised Learning으로 진행됨 . | long contiguous sequence만을 학습시키기 위해 Wikipedia는 text passage만 추출하여 사용 . | . . BERT의 Pre-training과 Fine-tuning . BERT의 Pre-training은 tokenization을 수행하여 embedding 된 Sentence 2개를 Input Data로 사용한다. (Input Data 생성에 대해서는 후술) Input 값은 Transformer layer를 거치며 문장 내에서 단어(token)스스로를 가장 잘 표현하는 Self-attention된 token vector(Contextual representation of token), 그리고 후술할 NSP(Next Sentence Prediction)와 MLM(Masked Language Model)을 거치며 언어의 맥락 정보를 저장한 모델을 구축함. . 이 후 Fine-tuning 과정에서는 pre-training 된 모델을 로드하여, MNLI, NER, SQuAD와 같은 다양한 NLP Classification task를 수행하는 labeled train data를 학습시켜 분류를 하게 됨. . 2) Tokenization . Subword segmentation . 단어 분리(Subword segmenation) 작업은 하나의 단어는 (단어보다 작은 단위의) 의미있는 여러 내부 단어들(subwords)의 조합으로 구성된 경우가 많기 때문에, 하나의 단어를 여러 내부 단어로 분리해서 단어를 이해해보겠다는 의도를 가진 전처리 작업 . | 더 적은 vocab으로 더 많은 단어를 표현하고 out of vocabulary 방지 . | . Bert의 Tokenization은 Subword segmentation의 하나인 WPM(word piece model, by Google) 기반으로 tokenization 된다. . Bert Tokenizer 모음 . Tokenization 과정 . Space 단위로 token 분리 . | Pretrained 된 WPM tokenizer 기준으로 subwords segmentation . | 문장 시작에 [CLS], 문장 끝에 [SEP], max_seq_len에 따라 [PAD] special token 붙이기 . | . 3) Input Embedding . Tokenization된 문장은 Token Embeddings, Sentence Embeddings, Positional Embedings를 합쳐 모델에 입력할 수 있는 Input Embedding 값으로 변환된다. . . BERT는 Input data로 3 가지의 vector들이 합쳐서 만들어짐 . 1) Token Embeddings : Input에 들어갈 2개의 문장을 단어 token 단위로 자르고 token을 수학적으로 표현함. 이후 NSL와 MLM을 실시하기 위해, sentence 순서를 50% 확률로 변경하고, 15%의 token을 masking함. Masked token의 80%는 masked([MSK])되고, 10%는 그대로, 10%는 다른 token으로 치환하게 됨. special token으로는 문장 가장 앞([CLS])과 문장이 분리되는 부분([SEP])에 들어가게 됨. . 2) Segment Embeddings : 문장의 순서를 Embedding함. 그림 상에서 A, B로 표현됨. . 3) Position Embeddings : 단어의 순서를 Embedding함. (Transformer는 RNN이나 CNN처럼 data를 순차적으로 연산하지 않기 때문에 단어와 문장의 순서정보를 token에 별도로 넣어줘야 함) 또한 같은 단어라도 쓰인 위치에 따라 다른 임베딩 값을 가질 수 있음 . . 4 )MLM (Masked Language Model) . token embedding 과정에서 각 문장 token을 15% 확률로 masked 하게 되며, (문맥을 계산하여) masked token이 무엇인지를 예측하는 학습을 진행함. . . 입력 token의 15%를 선택하여 80% [MASK], 10% 랜덤토큰대체, 10% 유지 . . 5) NSP (Next Sentence Prediction) . NSP를 위해 corpus에서 실제 next sentence와 random sentence를 50% 확률로 가져오게 되며, 이를 가지고 IsNext인지 NotNext인지를 예측하는 학습을 진행. (Segment embedding으로 문장의 순서 정보를 보존) . sentence_a = “신용 대출을 신청 하고 싶어요” . sentence_b = “대출 관련 서류를 준비해 오셨어요?” . Label: IsNext . sentence_a = “신용 대출을 신청 하고 싶어요” . sentence_b = ”어떤 팀이 올해 프로야구 우승 했나요?” . Label: NotNext . | . MLM &amp; NSP 방식 . . 3. Fine-tuning(Classification Layer) . Pre-training된 모델을 불러와 NLP task를 하는데 사용할 수 있음. 크게 4가지 유형으로 구분된다. . 모델은 pre-trained parameters로 초기화 되고 각각 downstream task 별로 다른 모델이 만들어진다. 문맥을 이해하는 Language Model위에 fine-tuning 방식으로 학습되므로 적은 label 데이터로도 높은 정확도를 갖는 모델을 생성할 수 있다. . . (a), (b)는 sequence-level task, (c)와 (d)는 token-level task로 각각의 특징은 다음과 같음. . (a)는 2개 sentence를 넣고 그 관계(pair classification)를 분류하는 task임. 문장의 유사 관계 분류 등에 사용되며 (b)는 1개 sentence를 넣고 감성과 같은 문장의 특성을 분류함 . (c)는 질문(Question)과 본문(Paragraph)을 넣고 문장 단위의 답을 호출함. paragraph에서 Q와 유사도가 높은 문장을 답으로 내놓기 위해, [SEP] token 이후의 00번째 token부터 00번째 token까지를 호출함. . d)는 1개 문장을 넣고, 문장 내 token의 정보를 분류함. NER(Named Entity Recognition, 개체명 인식)이나 형태소 분석과 같이 single sentence에서 각 token이 어떤 class를 갖는지 모두 classifier 적용하여 정답을 찾아냄. .",
            "url": "https://inspiringpeople.github.io/tech_blog/2020/09/10/BERT.html",
            "relUrl": "/2020/09/10/BERT.html",
            "date": " • Sep 10, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Title",
            "content": "from bertviz import head_view from transformers import DistilBertModel, DistilBertTokenizer . %%javascript require.config({ paths: { d3: &#39;//cdnjs.cloudflare.com/ajax/libs/d3/3.4.8/d3.min&#39;, jquery: &#39;//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min&#39;, } }); . def show_head_view(model, tokenizer, text): inputs = tokenizer.encode_plus(text, return_tensors=&#39;pt&#39;, add_special_tokens=True) input_ids = inputs[&#39;input_ids&#39;] attention = model(input_ids)[-1] input_id_list = input_ids[0].tolist() # Batch index 0 tokens = tokenizer.convert_ids_to_tokens(input_id_list) head_view(attention, tokens) . model_version = &#39;distilbert-base-uncased&#39; do_lower_case = True model = DistilBertModel.from_pretrained(model_version, output_attentions=True) tokenizer = DistilBertTokenizer.from_pretrained(model_version, do_lower_case=do_lower_case) . text = &quot;The cat sat on the mat. the dog lay on&quot; show_head_view(model, tokenizer, text) . Layer:",
            "url": "https://inspiringpeople.github.io/tech_blog/2020/09/09/head_view_distilbert.html",
            "relUrl": "/2020/09/09/head_view_distilbert.html",
            "date": " • Sep 9, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "fastcore: An Underrated Python Library",
            "content": ". Background . I recently embarked on a journey to sharpen my python skills: I wanted to learn advanced patterns, idioms, and techniques. I started with reading books on advanced Python, however, the information didn&#39;t seem to stick without having somewhere to apply it. I also wanted the ability to ask questions from an expert while I was learning -- which is an arrangement that is hard to find! That&#39;s when it occurred to me: What if I could find an open source project that has fairly advanced python code and write documentation and tests? I made a bet that if I did this it would force me to learn everything very deeply, and the maintainers would be appreciative of my work and be willing to answer my questions. . And that&#39;s exactly what I did over the past month! I&#39;m pleased to report that it has been the most efficient learning experience I&#39;ve ever experienced. I&#39;ve discovered that writing documentation forced me to deeply understand not just what the code does but also why the code works the way it does, and to explore edge cases while writing tests. Most importantly, I was able to ask questions when I was stuck, and maintainers were willing to devote extra time knowing that their mentorship was in service of making their code more accessible! It turns out the library I choose, fastcore is some of the most fascinating Python I have ever encountered as its purpose and goals are fairly unique. . For the uninitiated, fastcore is a library on top of which many fast.ai projects are built on. Most importantly, fastcore extends the python programming language and strives to eliminate boilerplate and add useful functionality for common tasks. In this blog post, I&#39;m going to highlight some of my favorite tools that fastcore provides, rather than sharing what I learned about python. My goal is to pique your interest in this library, and hopefully motivate you to check out the documentation after you are done to learn more! . Why fastcore is interesting . Get exposed to ideas from other languages without leaving python: I’ve always heard that it is beneficial to learn other languages in order to become a better programmer. From a pragmatic point of view, I’ve found it difficult to learn other languages because I could never use them at work. Fastcore extends python to include patterns found in languages as diverse as Julia, Ruby and Haskell. Now that I understand these tools I am motivated to learn other languages. | You get a new set of pragmatic tools: fastcore includes utilities that will allow you to write more concise expressive code, and perhaps solve new problems. | Learn more about the Python programming language: Because fastcore extends the python programming language, many advanced concepts are exposed during the process. For the motivated, this is a great way to see how many of the internals of python work. | A whirlwind tour through fastcore . Here are some things you can do with fastcore that immediately caught my attention. . . Making **kwargs transparent . Whenever I see a function that has the argument **kwargs, I cringe a little. This is because it means the API is obfuscated and I have to read the source code to figure out what valid parameters might be. Consider the below example: . def baz(a, b=2, c =3, d=4): return a + b + c def foo(c, a, **kwargs): return c + baz(a, **kwargs) inspect.signature(foo) . &lt;Signature (c, a, **kwargs)&gt; . Without reading the source code, it might be hard for me to know that foo also accepts and additional parameters b and d. We can fix this with delegates: . def baz(a, b=2, c =3, d=4): return a + b + c @delegates(baz) # this decorator will pass down keyword arguments from baz def foo(c, a, **kwargs): return c + baz(a, **kwargs) inspect.signature(foo) . &lt;Signature (c, a, b=2, d=4)&gt; . You can customize the behavior of this decorator. For example, you can have your cake and eat it too by passing down your arguments and also keeping **kwargs: . @delegates(baz, keep=True) def foo(c, a, **kwargs): return c + baz(a, **kwargs) inspect.signature(foo) . &lt;Signature (c, a, b=2, d=4, **kwargs)&gt; . You can also exclude arguments. For example, we exclude argument d from delegation: . def basefoo(a, b=2, c =3, d=4): pass @delegates(basefoo, but= [&#39;d&#39;]) # exclude `d` def foo(c, a, **kwargs): pass inspect.signature(foo) . &lt;Signature (c, a, b=2)&gt; . You can also delegate between classes: . class BaseFoo: def __init__(self, e, c=2): pass @delegates()# since no argument was passsed here we delegate to the superclass class Foo(BaseFoo): def __init__(self, a, b=1, **kwargs): super().__init__(**kwargs) inspect.signature(Foo) . &lt;Signature (a, b=1, c=2)&gt; . For more information, read the docs on delegates. . . Avoid boilerplate when setting instance attributes . Have you ever wondered if it was possible to avoid the boilerplate involved with setting attributes in __init__? . class Test: def __init__(self, a, b ,c): self.a, self.b, self.c = a, b, c . Ouch! That was painful. Look at all the repeated variable names. Do I really have to repeat myself like this when defining a class? Not Anymore! Checkout store_attr: . class Test: def __init__(self, a, b, c): store_attr() t = Test(5,4,3) assert t.b == 4 . You can also exclude certain attributes: . class Test: def __init__(self, a, b, c): store_attr(but=[&#39;c&#39;]) t = Test(5,4,3) assert t.b == 4 assert not hasattr(t, &#39;c&#39;) . There are many more ways of customizing and using store_attr than I highlighted here. Check out the docs for more detail. . . Avoiding subclassing boilerplate . One thing I hate about python is the __super__().__init__() boilerplate associated with subclassing. For example: . class ParentClass: def __init__(self): self.some_attr = &#39;hello&#39; class ChildClass(ParentClass): def __init__(self): super().__init__() cc = ChildClass() assert cc.some_attr == &#39;hello&#39; # only accessible b/c you used super . We can avoid this boilerplate by using the metaclass PrePostInitMeta. We define a new class called NewParent that is a wrapper around the ParentClass: . class NewParent(ParentClass, metaclass=PrePostInitMeta): def __pre_init__(self, *args, **kwargs): super().__init__() class ChildClass(NewParent): def __init__(self):pass sc = ChildClass() assert sc.some_attr == &#39;hello&#39; . . Type Dispatch . Type dispatch, or Multiple dispatch, allows you to change the way a function behaves based upon the input types it receives. This is a prominent feature in some programming languages like Julia. For example, this is a conceptual example of how multiple dispatch works in Julia, returning different values depending on the input types of x and y: . collide_with(x::Asteroid, y::Asteroid) = ... # deal with asteroid hitting asteroid collide_with(x::Asteroid, y::Spaceship) = ... # deal with asteroid hitting spaceship collide_with(x::Spaceship, y::Asteroid) = ... # deal with spaceship hitting asteroid collide_with(x::Spaceship, y::Spaceship) = ... # deal with spaceship hitting spaceship . Type dispatch can be especially useful in data science, where you might allow different input types (i.e. Numpy arrays and Pandas dataframes) to a function that processes data. Type dispatch allows you to have a common API for functions that do similar tasks. . Unfortunately, Python does not support this out-of-the box. Fortunately, there is the @typedispatch decorator to the rescue. This decorator relies upon type hints in order to route inputs the correct version of the function: . @typedispatch def f(x:str, y:str): return f&#39;{x}{y}&#39; @typedispatch def f(x:np.ndarray): return x.sum() @typedispatch def f(x:int, y:int): return x+y . Below is a demonstration of type dispatch at work for the function f: . f(&#39;Hello &#39;, &#39;World!&#39;) . &#39;Hello World!&#39; . f(2,3) . 5 . f(np.array([5,5,5,5])) . 20 . There are limitations of this feature, as well as other ways of using this functionality that you can read about here. In the process of learning about typed dispatch, I also found a python library called multipledispatch made by Mathhew Rocklin (the creator of Dask). . After using this feature, I am now motivated to learn languages like Julia to discover what other paradigms I might be missing. . . A better version of functools.partial . functools.partial is a great utility that creates functions from other functions that lets you set default values. Lets take this function for example that filters a list to only contain values &gt;= val: . test_input = [1,2,3,4,5,6] def f(arr, val): &quot;Filter a list to remove any values that are less than val.&quot; return [x for x in arr if x &gt;= val] f(test_input, 3) . [3, 4, 5, 6] . You can create a new function out of this function using partial that sets the default value to 5: . filter5 = partial(f, val=5) filter5(test_input) . [5, 6] . One problem with partial is that it removes the original docstring and replaces it with a generic docstring: . filter5.__doc__ . &#39;partial(func, *args, **keywords) - new function with partial application n of the given arguments and keywords. n&#39; . fastcore.utils.partialler fixes this, and makes sure the docstring is retained such that the new API is transparent: . filter5 = partialler(f, val=5) filter5.__doc__ . &#39;Filter a list to remove any values that are less than val.&#39; . . Composition of functions . A technique that is pervasive in functional programming languages is function composition, whereby you chain a bunch of functions together to achieve some kind of result. This is especially useful when applying various data transformations. Consider a toy example where I have three functions: (1) Removes elements of a list less than 5 (from the prior section) (2) adds 2 to each number (3) sums all the numbers: . def add(arr, val): return [x + val for x in arr] def arrsum(arr): return sum(arr) # See the previous section on partialler add2 = partialler(add, val=2) transform = compose(filter5, add2, arrsum) transform([1,2,3,4,5,6]) . 15 . But why is this useful? You might me thinking, I can accomplish the same thing with: . arrsum(add2(filter5([1,2,3,4,5,6]))) . You are not wrong! However, composition gives you a convenient interface in case you want to do something like the following: . def fit(x, transforms:list): &quot;fit a model after performing transformations&quot; x = compose(*transforms)(x) y = [np.mean(x)] * len(x) # its a dumb model. Don&#39;t judge me return y # filters out elements &lt; 5, adds 2, then predicts the mean fit(x=[1,2,3,4,5,6], transforms=[filter5, add2]) . [7.5, 7.5] . For more information about compose, read the docs. . . A more useful __repr__ . In python, __repr__ helps you get information about an object for logging and debugging. Below is what you get by default when you define a new class. (Note: we are using store_attr, which was discussed earlier). . class Test: def __init__(self, a, b=2, c=3): store_attr() # `store_attr` was discussed previously Test(1) . &lt;__main__.Test at 0x7fe0ab662790&gt; . We can use basic_repr to quickly give us a more sensible default: . class Test: def __init__(self, a, b=2, c=3): store_attr() __repr__ = basic_repr(&#39;a,b,c&#39;) Test(2) . Test(a=2, b=2, c=3) . . Monkey Patching With A Decorator . It can be convenient to monkey patch with a decorator, which is especially helpful when you want to patch an external library you are importing. We can use the decorator @patch from fastcore.foundation along with type hints like so: . class MyClass(int): pass @patch def func(self:MyClass, a): return self+a mc = MyClass(3) . Now, MyClass has an additional method named func: . mc.func(10) . 13 . Still not convinced? I&#39;ll show you another example of this kind of patching in the next section. . . A better pathlib.Path . When you see these extensions to pathlib.path you won&#39;t ever use vanilla pathlib again! A number of additional methods have been added to pathlib, such as: . Path.readlines: same as with open(&#39;somefile&#39;, &#39;r&#39;) as f: f.readlines() | Path.read: same as with open(&#39;somefile&#39;, &#39;r&#39;) as f: f.read() | Path.save: saves file as pickle | Path.load: loads pickle file | Path.ls: shows the contents of the path as a list. | etc. | . Read more about this here. Here is a demonstration of ls: . from pathlib import Path p = Path(&#39;../_notebooks&#39;) p.ls() # you don&#39;t get this with vanilla Pathlib.Path!! . (#21) [Path(&#39;../_notebooks/gpt2_simple_mask.jpg&#39;),Path(&#39;../_notebooks/bert_mac_small.jpg&#39;),Path(&#39;../_notebooks/causal_with_prefix.jpg&#39;),Path(&#39;../_notebooks/.DS_Store&#39;),Path(&#39;../_notebooks/2020-03-07-How_to_Create_an_Automatic_Code_Comment_Generator_using_Deep_Learning.ipynb&#39;),Path(&#39;../_notebooks/2020-09-01-fastcore.ipynb&#39;),Path(&#39;../_notebooks/2020-03-07-Syntax-Highlighting.ipynb&#39;),Path(&#39;../_notebooks/2020-03-06-bart.ipynb&#39;),Path(&#39;../_notebooks/README.md&#39;),Path(&#39;../_notebooks/2020-05-01-TrainDonkeyCar.ipynb&#39;)...] . Wait! What&#39;s going on here? We just imported pathlib.Path - why are we getting this new functionality? Thats because we imported the fastcore.foundation module, which patches this module via the @patch decorator discussed earlier. Just to drive the point home on why the @patch decorator is useful, I&#39;ll go ahead and add another method to Path right now: . @patch def fun(self:Path): return &quot;This is fun!&quot; p.fun() . &#39;This is fun!&#39; . That is magical, right? I know! That&#39;s why I&#39;m writing about it! . . An Even More Concise Way To Create Lambdas . Self, with an uppercase S, is an even more concise way to create lambdas that are calling methods on an object. For example, let&#39;s create a lambda for taking the sum of a Numpy array: . arr=np.array([5,4,3,2,1]) f = lambda a: a.sum() assert f(arr) == 15 . You can use Self in the same way: . f = Self.sum() assert f(arr) == 15 . Let&#39;s create a lambda that does a groupby and max of a Pandas dataframe: . import pandas as pd df=pd.DataFrame({&#39;Some Column&#39;: [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, ], &#39;Another Column&#39;: [5, 7, 50, 70]}) f = Self.groupby(&#39;Some Column&#39;).mean() f(df) . Another Column . Some Column . a 6 | . b 60 | . Read more about Self in the docs). . . Notebook Functions . These are simple but handy, and allow you to know whether or not code is executing in a Jupyter Notebook, Colab, or an Ipython Shell: . in_notebook(), in_colab(), in_ipython() . (True, False, True) . This is useful if you are displaying certain types of visualizations, progress bars or animations in your code that you may want to modify or toggle depending on the environment. . . A Drop-In Replacement For List . You might be pretty happy with Python&#39;s list. This is one of those situations that you don&#39;t know you needed a better list until someone showed one to you. Enter L, a list like object with many extra goodies. . The best way I can describe L is to pretend that list and numpy had a pretty baby: . define a list (check out the nice __repr__ that shows the length of the list!) . L(1,2,3) . (#3) [1,2,3] . Shuffle a list: . p = L.range(20).shuffle() p . (#20) [2,0,18,6,15,17,14,8,12,1...] . Index into a list: . p[2,4,6] . (#3) [18,15,14] . L has sensible defaults, for example appending an element to a list: . 1 + L(2,3,4) . (#4) [1,2,3,4] . There is much more L has to offer. Read the docs to learn more. . But Wait ... There&#39;s More! . There are more things I would like to show you about fastcore, but there is no way they would reasonably fit into a blog post. Here is a list of some of my favorite things that I didn&#39;t demo in this blog post: . Utilities . The Utilites section contain many shortcuts to perform common tasks or provide an additional interface to what standard python provides. . mk_class: quickly add a bunch of attributes to a class | wrap_class: add new methods to a class with a simple decorator | groupby: similar to Scala&#39;s groupby | merge: merge dicts | fasttuple: a tuple on steroids | Infinite Lists: useful for padding and testing | chunked: for batching and organizing stuff | . Multiprocessing . The Multiprocessing section extends python&#39;s multiprocessing library by offering features like: . progress bars | ability to pause to mitigate race conditions with external services | processing things in batches on each worker, ex: if you have a vectorized operation to perform in chunks | . Functional Programming . The functional programming section is my favorite part of this library. . maps: a map that also composes functions | mapped: A more robust map | using_attr: compose a function that operates on an attribute | . Transforms . Transforms is a collection of utilities for creating data transformations and associated pipelines. These transformation utilities build upon many of the building blocks discussed in this blog post. . Further Reading . It should be noted that you should read the main page of the docs first, followed by the section on tests to fully understand the documentation. . The fastcore documentation site. | The fastcore GitHub repo. | Blog post on delegation. | . Shameless plug: fastpages . This blog post was written entirely in a Jupyter Notebook, which GitHub automatically converted into to a blog post! Sound interesting? Check out fastpages. .",
            "url": "https://inspiringpeople.github.io/tech_blog/fastcore/",
            "relUrl": "/fastcore/",
            "date": " • Sep 1, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . #collapse-hide import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . #collapse-show cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # single-value selection over [Major_Genre, MPAA_Rating] pairs # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . # select a point for which to provide details-on-demand label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . # display table with pandas df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://inspiringpeople.github.io/tech_blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://inspiringpeople.github.io/tech_blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "AI와 함께 작곡한다면?",
            "content": "AI를 통해 사람의 창의성을 발현 시키는 것은 가능한 일일까? . . 이것이 가능한지, 또 옳은일인지에 대해 다양한 의견이 있고 서로의 입장이 워낙 견고하다. 듣고 보는 것만으로는 그 정도를 가늠하기가 어려워서 이 질문을 나에게 적용해보기로 했다. . 예술가가 되기 - 인생의 어느 작은 구석에서라도 예술성을 실현하며 살기. . “인생의 어느 작은 구석에서라도 예술성을 실현하기”는 내 인생 모토 중 큰 부분을 차지하는 것이기도해서 좋은 실험 기회가 되었다. 내가 도전한 부분은 AI를 통해 작곡(편곡)하기였다. 타겟 곡은 평소 좋아하던 Pudditorium의 If I could meet again이라는 음악이다. 반복적인 멜로디에 여러 악기가 덧입혀지면서 분위기가 고조되고 독특한 분위기를 풍기는 곡인데, 피아노로 따라치면 그 분위기는 모두 없어지고 선율만 남아 아쉬움이 컸다. 내가 표현할 수 없었던 피아노 이외의 부분을 AI로 표현하면 좋을 것 같아 이 곡을 선정하게 되었다. . 원곡을 들어보자 (클릭하면 재생) . . 아름답다. 리더 김정범 씨가 어머니를 생각하며 만든 곡이라고 한다. . 이 훌륭한 곡을 잘 들어보면 아래 멜로디 라인이 반복됨을 알 수 있다. (이렇게 간단한 멜로디에 아름다운 음악이라니!) . . 이 멜로디를 토대로 구글 마젠타 스튜디오를 이용해서 내가 혼자 연주할 때보다 업그레이드 된 새로운 느낌의 곡을 만들어보았다. . 마젠타로 재현한 음악 (클릭하면 재생) . . 위 곡을 만들기 위해 사용한 Magenta Studio는 아래 사이트에 가면 확인해 볼 수 있다. Magenta Studio는 machine learning을 이용해서 music generation을 가능하게 하는 open source tool이다. 이것은 standalone으로도 동작하고 ableton DAW 상에서 plugin 방식으로도 사용된다. . 구글 마젠타 스튜디오 : https://magenta.tensorflow.org/studio . . 내가 위 곡을 만들기 위해 진행한 과정은 다음과 같다. . 8마디 피아노 + 8마디 스트링 (직접 연주) . 곡의 뼈대를 만들기 위해 위 악보에 채보되어 있는 멜로디 라인을 처음에는 피아노, 그 다음에는 스트링을 이용해서 직접 연주 . | Magenta Drumify : Drum bit Generation . 곡에 드럼라인을 입히기 위해 Drumify를 이용해서 비트 생성 . | Magenta Arpeggio Generation . https://codepen.io/teropa/full/ddqEwj/ . 위 사이트에서 제공하는 아르페지오 생성기를 사용 . | Magenta Continue : Bass Solo Generation . 멜로디를 input으로 하여 그에 맞는 bass solo 라인 생성 (2개 종류) . | Magenta Interpolate : Additional Bass Solo . 4번에서 생성된 2개 bass solo를 input으로 받아 이 둘 라인을 자연스럽게 연결해 줄 수 있는 additional bass solo 생성 . | . 단상 . 곡을 만들기 위해 Magenta Studio를 이용해서 여러 시도를 해보고 조합하는데에는 시간이 별로 들지 않았다. 15분 정도, 충분힌 시간을 가지고 다양한 시도를 한다면 더 멋진 곡이 나올수도. 하지만 Ableton DAW를 처음 접해보는지라, 기능 숙지하는데에 시간이 오히려 더 많이 걸렸다. 또한 사람이 작곡하는 경우에는 멜로디 라인에 따라 의도하는 화성, 감정선이 있을건데 Magenta를 이용해서 generation을 해서 끼워넣을 경우 그 감성이 깨지는 듯한 인상도 받았다. 따라서 짧은 멜로디 진행에 더 잘 어울릴 것 같다. 그 밖에 자신이 주로 연주하는 악기 외에도 다양한 악기를 나의 input에 맞게 생성해 볼 수 있으니 창작자에게 좋은 seed가 될 수 있을 것이라고 생각한다. 마젠타에 흥미로운 주제의 프로젝트가 많으니 시도해본다면 시간가는 줄 모를 것이다. . AI를 이용해 사람의 창의성을 발현 시키는 것이 가능한 일일까? 처음 했던 이 질문에 대한 대답을 한다면, Absolutely, Yes. 다만 그것을 인간이 허용할지 안할지에 대한 의사결정이 필요할 뿐… . (참고영상) . .",
            "url": "https://inspiringpeople.github.io/tech_blog/data%20analysis/2019/07/08/magenta_studio.html",
            "relUrl": "/data%20analysis/2019/07/08/magenta_studio.html",
            "date": " • Jul 8, 2019"
        }
        
    
  
    
        ,"post7": {
            "title": "Happy Faces",
            "content": "AI가 인간을 이해하는데 도움을 줄 수 있을까. 사회가 정의한 ‘행복’이라는 것은 무엇일까. 또한 그것은 우리가 볼 수 있는 유형의 것으로 표현될 수 있을까.라는 질문들로 시작된, Creative AI 첫번째 프로젝트이다. . . 우선 많은 사람들의 행복한 (웃는) 이미지들을 모아서 ‘Happy Eigen Face’를 만들었다. 그리고 새로운 얼굴 표정이 입력되면 이 얼굴이 ‘Happy Eigen Face’로 투영해가는 과정을 표현했다. 한 사람의 감정이 사회의 감정으로 투영해 가는 과정을 그린 것이다. 너와 내가 다르게 보일지라도 우리는 어떤 공통된 모습이 있고, 그 지점으로부터 모두 연결될 수 있다는 메시지를 주고 싶었다. 사람이 아니라서, 동떨어진 시선으로 볼 수 있는 AI라서, 그것으로부터 제공된 ‘공통요소, 동질감’이라는 것은 어쩌면 가끔 쿨하게 받아들여질 수 있지 않을까. 아래에 작업한 모델링 관련 소스 코드와 완성된 영상이 공유한다. 작업은 모두연 DLC 3기 전도희님, 곽현일님과 같이 작업하였고, 나는 모델링 부분을, 두 분은 전처리와 시각화 부분을 맡아주셨다.(시각화 부분 짱, 나도 저렇게 언젠간 interactive한 시각화를 해보고 싶다.) 어쩌면 작업 전, 후에 의도했던 결들이 조금씩 달라졌을지 모르지만, 사람을 돕는 AI라는 주제는 여전히 같다. 프로젝트 팀원분들 모두 적극적이고 아이디어가 샘솟아서 작업하면서 너무 즐거웠다. . . 우선 모델링 결과로 나온 이미지를 interactive하게 시각화한 데모 영상을 먼저 보자. 원래는 마우스 훨이나 키보드 입력에 따라 동적으로 움직이는데, 영상에는 일부만 표현됨 (클릭 시 동영상 재생). . . . 이제 모델링 부분 공유 시작. 사회가 정의한 행복을 표현하기 위해 우선 아래 링크의 Open dataset에서 얼굴 사진을 획득하고 웃는 얼굴만 사용하기 위해 Face_Emotion_Detecion이라는 Pre-trained Model을 사용하였다 . Dataset : scikit learn open data set 10명의 다양한 표정 데이터 400장 보유 . Pre-trained Model : Face_emotion_detection model . . 작업순서 . Pretraining 된 face emotion model을 이용하여 data set 중 happy로 라벨링된 표정 사진만 추출 | 10명의 총 400장 사진 중 108장이 추출됨 | 108장의 happy한 표정 데이터에 대한 eigen face를 도출하여 2차원으로 표현 (AI로 표현되는 Happy face) | Happy로 대표되는 eigen face에 나/나의 얼굴은 어떻게 투영될 것인가? | Input 이미지가 Eigen face에 투영되는 과정을 weight를 변화시켜가며 표현 | . # -*- coding: utf-8 -*- import cv2 import numpy as np from keras.models import load_model import sys ##Satart Section &#39;&#39;&#39; Keras took all GPU memory so to limit GPU usage, I have add those lines&#39;&#39;&#39; import tensorflow as tf from keras.backend.tensorflow_backend import set_session config = tf.ConfigProto() config.gpu_options.per_process_gpu_memory_fraction = 0.1 set_session(tf.Session(config=config)) &#39;&#39;&#39; Keras took all GPU memory so to limit GPU usage, I have add those lines&#39;&#39;&#39; ## End section import tensorflow.keras from keras.preprocessing import image from keras.applications.imagenet_utils import decode_predictions, preprocess_input from keras.models import Model . Using TensorFlow backend. . 데이터 셋 다운로드 . from sklearn.datasets import fetch_olivetti_faces from sklearn.decomposition import PCA import matplotlib.pyplot as plt import numpy as np faces_all = fetch_olivetti_faces() . Face_emotion_detection을 위해 pre-trained된 모델과 xml 파일 다운로드해서 colab에 업로드 &amp; 로딩 . faceCascade = cv2.CascadeClassifier(&#39;haarcascade_frontalface_alt2.xml&#39;) model = load_model(&#39;model_5-49-0.62.hdf5&#39;) . WARNING:tensorflow:From /usr/local/lib/python3.6/dist-packages/tensorflow/python/framework/op_def_library.py:263: colocate_with (from tensorflow.python.framework.ops) is deprecated and will be removed in a future version. Instructions for updating: Colocations handled automatically by placer. WARNING:tensorflow:From /usr/local/lib/python3.6/dist-packages/keras/backend/tensorflow_backend.py:3445: calling dropout (from tensorflow.python.ops.nn_ops) with keep_prob is deprecated and will be removed in a future version. Instructions for updating: Please use `rate` instead of `keep_prob`. Rate should be set to `rate = 1 - keep_prob`. WARNING:tensorflow:From /usr/local/lib/python3.6/dist-packages/tensorflow/python/ops/math_ops.py:3066: to_int32 (from tensorflow.python.ops.math_ops) is deprecated and will be removed in a future version. Instructions for updating: Use tf.cast instead. /usr/local/lib/python3.6/dist-packages/keras/engine/saving.py:327: UserWarning: Error in loading the saved optimizer state. As a result, your model is starting with a freshly initialized optimizer. warnings.warn(&#39;Error in loading the saved optimizer &#39; . model.summary() . _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= conv2d_1 (Conv2D) (None, 64, 48, 48) 640 _________________________________________________________________ dropout_1 (Dropout) (None, 64, 48, 48) 0 _________________________________________________________________ max_pooling2d_1 (MaxPooling2 (None, 64, 24, 24) 0 _________________________________________________________________ conv2d_2 (Conv2D) (None, 128, 24, 24) 204928 _________________________________________________________________ dropout_2 (Dropout) (None, 128, 24, 24) 0 _________________________________________________________________ max_pooling2d_2 (MaxPooling2 (None, 128, 12, 12) 0 _________________________________________________________________ conv2d_3 (Conv2D) (None, 512, 12, 12) 590336 _________________________________________________________________ dropout_3 (Dropout) (None, 512, 12, 12) 0 _________________________________________________________________ max_pooling2d_3 (MaxPooling2 (None, 512, 6, 6) 0 _________________________________________________________________ conv2d_4 (Conv2D) (None, 512, 6, 6) 2359808 _________________________________________________________________ dropout_4 (Dropout) (None, 512, 6, 6) 0 _________________________________________________________________ max_pooling2d_4 (MaxPooling2 (None, 512, 3, 3) 0 _________________________________________________________________ flatten_1 (Flatten) (None, 4608) 0 _________________________________________________________________ dense_1 (Dense) (None, 256) 1179904 _________________________________________________________________ dropout_5 (Dropout) (None, 256) 0 _________________________________________________________________ dense_2 (Dense) (None, 512) 131584 _________________________________________________________________ dropout_6 (Dropout) (None, 512) 0 _________________________________________________________________ dense_3 (Dense) (None, 7) 3591 ================================================================= Total params: 4,470,791 Trainable params: 4,470,791 Non-trainable params: 0 _________________________________________________________________ . Pre-trained 모델을 사용하여 새로운 얼굴 사진이 들어오면 다음 7가지 감정 중 하나로 라벨링한다. . ‘angry’, ‘disgust’, ‘fear’, ‘happy’, ‘sad’, ‘surprise’ ,’neutral’ | . def test_image(addr): target = [&#39;angry&#39;,&#39;disgust&#39;,&#39;fear&#39;,&#39;happy&#39;,&#39;sad&#39;,&#39;surprise&#39;,&#39;neutral&#39;] font = cv2.FONT_HERSHEY_SIMPLEX faces = addr faces = cv2.resize(faces,(48,48)) faces = faces.reshape(1, 1,faces.shape[0],faces.shape[1]) result = target[np.argmax(model.predict(faces))] #print(result) return result . print(len(faces_all.images)) h_imgs=[] h_data=[] for i in range(len(faces_all.images)): if(test_image(faces_all.images[i])==&#39;happy&#39;): h_imgs.append(faces_all.images[i]) h_data.append(faces_all.data[i]) . 400 . print(len(h_imgs)) . 108 . 모델을 이용하여 happy로 라벨링 된 이미지 확인 전체 400장 얼굴 사진 중 108장의 얼굴이 Happy로 라벨링되었고, 이 사진들을 확인해본다. . N = 10 M = 10 fig = plt.figure(figsize=(10, 10)) plt.subplots_adjust(top=1, bottom=0, hspace=0, wspace=0.05) for i in range(N): for j in range(M): k = i * M + j ax = fig.add_subplot(N, M, k+1) ax.imshow(h_imgs[k], cmap=plt.cm.bone) ax.grid(False) ax.xaxis.set_ticks([]) ax.yaxis.set_ticks([]) plt.tight_layout() plt.show() . . 위 108장에 대한 Happy Face를 표현하는 주성분을 파악하기 위해 2개로 PCA 분석 진행한다 . from sklearn.decomposition import PCA pca3 = PCA(n_components=2) X3 = h_data W3 = pca3.fit_transform(X3) X32 = pca3.inverse_transform(W3) . 주성분으로 각 표정 데이터를 근사화 시키고 이미지를 저장함 . N = 10 M = 10 fig = plt.figure(figsize=(10, 10)) plt.subplots_adjust(top=1, bottom=0, hspace=0, wspace=0.05) for i in range(N): for j in range(M): k = i * M + j ax = fig.add_subplot(N, M, k+1) ax.imshow(X32[k].reshape(64, 64), cmap=plt.cm.bone) #cv2.imwrite(str(i)+&#39;_&#39;+str(j)+&#39;_happy_common.jpg&#39;, X32[k].reshape(64, 64)*255) ax.grid(False) ax.xaxis.set_ticks([]) ax.yaxis.set_ticks([]) #plt.suptitle(&quot;PCA : Happy faces&quot;) plt.tight_layout() plt.show() . . pca3.mean_.shape . (4096,) . 주성분으로 표현된 eigen face, 여기서는 100장의 happy face를 대표하는 얼굴과 각 주성분 PCA1, PCA2의 이미지를 확인한다 . face_mean = pca3.mean_.reshape(64, 64) face_p1 = pca3.components_[0].reshape(64, 64) face_p2 = pca3.components_[1].reshape(64, 64) plt.subplot(131) plt.imshow(face_mean, cmap=plt.cm.bone) plt.grid(False) plt.xticks([]) plt.yticks([]) plt.title(&quot;Mean Face&quot;) plt.subplot(132) plt.imshow(face_p1, cmap=plt.cm.bone) plt.grid(False) plt.xticks([]) plt.yticks([]) plt.title(&quot;PCA 1&quot;) plt.subplot(133) plt.imshow(face_p2, cmap=plt.cm.bone) plt.grid(False) plt.xticks([]) plt.yticks([]) plt.title(&quot;PCA 2&quot;) plt.show() . . mean_face, pca1_face, pca2_face 저장 . cv2.imwrite(&#39;mean_face.jpg&#39;, face_mean*255) cv2.imwrite(&#39;p1_face.jpg&#39;, face_p1*255) cv2.imwrite(&#39;p2_face.jpg&#39;, face_p2*255) . True . face_mean.shape . (64, 64) . 특정 인물의 사진을 happy eigen face로 투영해가는 과정 . happy face 얼굴 중 0번째 얼굴을 특정 인물이라고 가정 | 특정 인물 -&gt; happy eigen face 변화를 50개 레벨로 세분화해서 표현 | 각 이미지의 가로/세로 padding을 2씩 넣어서 저장 | . plt.imshow(h_imgs[0], cmap=plt.cm.bone) cv2.imwrite(&#39;org.jpg&#39;, h_imgs[0]*255) . True . . .",
            "url": "https://inspiringpeople.github.io/tech_blog/data%20analysis/2019/05/20/MyHappyfaces.html",
            "relUrl": "/data%20analysis/2019/05/20/MyHappyfaces.html",
            "date": " • May 20, 2019"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "좋아하는 글귀",
          "content": "달리기를 말할 때 내가 하고 싶은 이야기 (무라카미하루키) 중에서 | . 강물을 생각하려 한다. 구름을 생각하려 한다. 나는 소박하고 아담한 공백 속을, 정겨운 침묵 속을 그저 계속 달려가고 있다. 그 누가 뭐라고 해도, 그것은 여간 멋진 일이 아니다. . 계속 하는 것-리듬을 단절 하지 않는 것, 장기적인 작업을 하는 데에는 그것이 중요하다. 일단 리듬이 설정되어지기만 하면, 그 뒤는 어떻게든 풀려 나간다. 그러나 탄력을 받은 바퀴가 일정한 속도로 확실하게 돌아가기 시작할 때까지는 계속 가속하는 힘을 멈추지 말아야 한다는 것은 아무리 주의를 기울인다고 해도 지나치지 않다. . 달리는 것은, 내가 이제까지의 인생을 사는 가운데 후천적으로 익혔던 몇 가지 습관 중에서 아마도 가장 유익하고 중요한 의미를 지닌 것이라고 생각된다. … 물론 나라고 해서 지는 걸 좋아할 리는 없다. 그러나 왠지 모르게 다른 사람을 상대로 이기거나 지거나 하는 경기에 대해서는 옛날부터 한결같이 그다지 연연하지 않았다. 그러한 성향은 어른이 된 뒤에도 대체로 변하지 않는다. 어떤 일이 됐든 다른 사람을 상대로 이기든 지든 그다지 신경 쓰지 않는다. 그보다는 나 자신이 설정한 기준을 만족시킬 수 있는가 없는가에 더 관심이 쏠린다. 그런 의미에서 장거리를 달리는 것은 나의 성격에 아주 잘 맞는 스포츠였다. …다시 말하면 끝까지 달리고 나서 자신에 대한 자부심(혹은 프라이드와 비슷한 것)을 가질 수 있는가 없는가, 그것이 장거리 러너에게 있어서의 중요한 기준이 된다…. 그런 의미에서 소설을 쓰는 것은 마라톤 풀코스를 뛰는 것과 비슷하다. 기본적인 원칙을 말한다면, 창작자에게 있어 그 동기는 자신 안에 조용히 확실하게 존재하는 것으로서, 외부에서 어떤 형태나 기준을 찾아야 할 일은 아니다. . 달린다는 것은 나에게 있어 유익한 운동인 동시에 유효한 메타포이기도 하다. … 어제의 자신이 지닌 약점을 조금이라도 극복해나가는 것, 그것이 더 중요한 것이다. 장거리 달리기에 있어서 이겨내야 할 상대가 있다면, 그것은 바로 과거의 자기 자신이기 때문이다. . 나이를 먹어간다는 것은 태어나서 처음으로 체험하는 것이고, 거기에서 느끼는 감정 역시 처음으로 맛보는 감정인 것이다. …그러나 나이를 먹어감에 따라, 그와 같은 괴로움이나 상처는 인생에 있어 어느 정도 필요한 것이다, 라는 점을 조금씩 깨닫게 되었다. 생각해보면 타인과 얼마간이나마 차이가 있는 것이야말로, 사람의 자아란 것을 형성하게 되고, 자립한 인간으로서의 모습을 유지해갈 수 있도록 만드는 것이다. … 내가 다른 누구도 아닌 ‘나’라는 것은, 나에게 있어 하나의 소중한 자산인 것이다. 마음이 받게 되는 아픈 상처는 그와 같은 인간의 자립성이 세계에 대해 지불하지 않으면 안 될 당연한 대가인것이다. . 타인으로부터의 고립과 단절은 병에서 새어 나온 신처럼 알지 못하는 사이에 사람의 마음을 갉아먹고 녹여버린다. 그것은 양날의 검과 같은 것이다. 사람의 마음을 보호하는 동시에, 그 내벽을 끊임없이 자잘하게 상처 내기도 한다. … 나는 신체를 끊임없이 물리적으로 움직여 나감으로써, 어떤 경우에는 극한으로까지 몰아감으로써, 내면에 안고 있는 고립과 단절의 느낌을 치유하고 객관화해 나가야 했던 것이다. 의도적이라기보다는 오히려 직감적으로. .",
          "url": "https://inspiringpeople.github.io/tech_blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://inspiringpeople.github.io/tech_blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}